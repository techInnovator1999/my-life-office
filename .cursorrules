# .cursorrules

## Project Overview
This is a full-stack CRM application called PipelineHub with:
- **Frontend**: React 18+ with TypeScript, Vite, Tailwind CSS
- **Backend**: Node.js with Express, TypeScript, Prisma ORM, PostgreSQL
- **Architecture**: MVC pattern for backend, Component-based for frontend
- **Key Features**: Kanban pipeline, contacts management, Google Contacts sync, role-based access control

---

## General Principles

### Code Philosophy
- Write code ONLY for current requirements, not future possibilities
- Avoid premature optimization
- No speculative features or "just in case" code
- Keep functions small and focused (max 50 lines)
- One function = one responsibility
- Delete unused code immediately
- No TODO comments - implement or create a task

### Code Quality
- Prefer readability over cleverness
- Use descriptive variable names (avoid single letters except in loops: i, j, k)
- No magic numbers - use named constants
- Avoid deep nesting (max 3 levels)
- No duplicate code - refactor when you copy-paste
- Comments explain "why", not "what"

### Error Handling
- Always handle errors explicitly
- No silent failures
- Provide meaningful error messages
- Use try-catch only when you can recover from the error
- Let errors bubble up if you can't handle them

---

## TypeScript Rules

### General TypeScript
- Use `type` for object shapes, `interface` for contracts that can be extended
- Avoid `any` - use `unknown` if type is truly unknown
- No implicit `any` - always specify types
- Use strict mode
- Prefer type inference when obvious
- Use `const` for immutable values, `let` for mutable (never `var`)
- Use optional chaining `?.` and nullish coalescing `??`

### Type Definitions
```typescript
// ✅ Good
type User = {
  id: string
  name: string
  email: string
  role: 'ADMIN' | 'AGENT'
}

// ❌ Bad - using interface when type is sufficient
interface User {
  id: string
  name: string
}

// ✅ Good - Use interface when extending
interface BaseEntity {
  id: string
  createdAt: Date
}

interface User extends BaseEntity {
  name: string
  email: string
}
```

### Avoid Over-Engineering Types
```typescript
// ❌ Bad - unnecessary complexity
type DeepPartial<T> = {
  [P in keyof T]?: T[P] extends object ? DeepPartial<T[P]> : T[P]
}

// ✅ Good - use built-in utilities
type UserUpdate = Partial<User>

// ❌ Bad - generic when not needed
function getUser<T extends User>(id: string): Promise<T> { }

// ✅ Good - specific type
function getUser(id: string): Promise<User> { }
```

---

## Frontend (React + TypeScript) Rules

### Project Structure
```
client/src/
├── components/       # Reusable UI components only
├── pages/           # Route-level components only
├── hooks/           # Custom hooks only
├── services/        # API calls only
├── utils/           # Pure utility functions only
├── types/           # TypeScript types only
├── constants/       # Constants only
└── App.tsx
```

### Component Rules

#### When to Create a Component
- Used in multiple places (actual reuse, not potential)
- Parent component exceeds 150 lines
- Distinct UI responsibility
- **Never** create components speculatively

#### Component Structure
```typescript
// ✅ Good - Clear, simple component
type ContactCardProps = {
  contact: Contact
  onEdit: (id: string) => void
  onDelete: (id: string) => void
}

export function ContactCard({ contact, onEdit, onDelete }: ContactCardProps) {
  return (
    <div className="card">
      <h3>{contact.name}</h3>
      <p>{contact.email}</p>
      <button onClick={() => onEdit(contact.id)}>Edit</button>
      <button onClick={() => onDelete(contact.id)}>Delete</button>
    </div>
  )
}

// ❌ Bad - Over-engineered
type ContactCardProps<T extends Contact = Contact> = {
  contact: T
  onEdit?: (id: string) => void | Promise<void>
  onDelete?: (id: string) => void | Promise<void>
  renderActions?: (contact: T) => React.ReactNode
  className?: string
  style?: React.CSSProperties
}
```

#### Component Organization
```typescript
// File: ContactCard.tsx

// 1. Imports
import { Contact } from '@/types'

// 2. Types (local to this file)
type ContactCardProps = {
  contact: Contact
  onEdit: (id: string) => void
}

// 3. Component
export function ContactCard({ contact, onEdit }: ContactCardProps) {
  // 3a. Hooks first
  const [isHovered, setIsHovered] = useState(false)
  
  // 3b. Event handlers
  const handleEdit = () => {
    onEdit(contact.id)
  }
  
  // 3c. Render
  return (
    <div onMouseEnter={() => setIsHovered(true)}>
      {/* JSX */}
    </div>
  )
}

// 4. No default exports for components
```

### Pages vs Components

#### Pages (Route Components)
```typescript
// ✅ Good - Page orchestrates components
// pages/Contacts.tsx
export function ContactsPage() {
  const { contacts, isLoading } = useContacts()
  const [selectedContact, setSelectedContact] = useState<Contact | null>(null)
  
  if (isLoading) return <LoadingSpinner />
  
  return (
    <div className="container">
      <ContactList 
        contacts={contacts}
        onSelect={setSelectedContact}
      />
      {selectedContact && (
        <ContactDrawer 
          contact={selectedContact}
          onClose={() => setSelectedContact(null)}
        />
      )}
    </div>
  )
}

// ❌ Bad - Page with embedded component logic
export function ContactsPage() {
  // 500 lines of mixed concerns
  return (
    <div>
      {/* Inline ContactList implementation */}
      {/* Inline ContactDrawer implementation */}
    </div>
  )
}
```

### State Management
```typescript
// ✅ Good - Local state for UI
function ContactCard({ contact }: Props) {
  const [isExpanded, setIsExpanded] = useState(false)
  return <div>{/* ... */}</div>
}

// ✅ Good - Context for shared state
const AuthContext = createContext<AuthContextType | null>(null)

// ❌ Bad - Prop drilling more than 2 levels deep
<Parent>
  <Child prop={value}>
    <GrandChild prop={value}>
      <GreatGrandChild prop={value} /> {/* Too deep! Use context */}
    </GrandChild>
  </Child>
</Parent>

// ❌ Bad - Context for everything
const ThemeContext = createContext()
const UserContext = createContext()
const ContactsContext = createContext()
const OpportunitiesContext = createContext()
// ... 10 more contexts (context hell!)
```

### Custom Hooks
```typescript
// ✅ Good - Encapsulates specific logic
function useContacts() {
  const [contacts, setContacts] = useState<Contact[]>([])
  const [isLoading, setIsLoading] = useState(false)
  const [error, setError] = useState<string | null>(null)
  
  useEffect(() => {
    fetchContacts()
  }, [])
  
  const fetchContacts = async () => {
    setIsLoading(true)
    try {
      const data = await contactService.getAll()
      setContacts(data)
    } catch (err) {
      setError(err.message)
    } finally {
      setIsLoading(false)
    }
  }
  
  return { contacts, isLoading, error, refetch: fetchContacts }
}

// ❌ Bad - Generic hook that does everything
function useApi<T>(endpoint: string, options?: Options) {
  // 200 lines of generic logic
  // Trying to handle every possible scenario
}
```

### API Service Layer
```typescript
// services/contactService.ts

// ✅ Good - Simple, focused service
import api from './api'

export const contactService = {
  getAll: async (): Promise<Contact[]> => {
    const { data } = await api.get('/contacts')
    return data
  },
  
  getById: async (id: string): Promise<Contact> => {
    const { data } = await api.get(`/contacts/${id}`)
    return data
  },
  
  create: async (contact: CreateContactDto): Promise<Contact> => {
    const { data } = await api.post('/contacts', contact)
    return data
  },
  
  update: async (id: string, contact: UpdateContactDto): Promise<Contact> => {
    const { data } = await api.put(`/contacts/${id}`, contact)
    return data
  },
  
  delete: async (id: string): Promise<void> => {
    await api.delete(`/contacts/${id}`)
  }
}

// ❌ Bad - Over-engineered service
class ContactService<T extends Contact> extends BaseService<T> {
  constructor(private config: ServiceConfig) {
    super(config)
  }
  
  // 300 lines of abstract methods
}
```

### Utility Functions
```typescript
// utils/formatters.ts

// ✅ Good - Pure, simple utility
export function formatPhoneNumber(phone: string): string {
  return phone.replace(/(\d{3})(\d{3})(\d{4})/, '($1) $2-$3')
}

export function formatDate(date: Date): string {
  return new Intl.DateTimeFormat('en-US').format(date)
}

// ❌ Bad - Utility that should be a hook
export function fetchAndFormatContacts() {
  // Uses useState, useEffect (this is a hook, not a utility!)
}

// ❌ Bad - Overly complex utility
export function deepCloneWithCircularReferenceHandling<T>(obj: T): T {
  // 100 lines of complex logic you'll never need
}
```

### No Unnecessary Abstractions
```typescript
// ❌ Bad - Wrapper for the sake of wrapping
function Button({ children, ...props }: ButtonProps) {
  return <button {...props}>{children}</button>
}

// ✅ Good - Only wrap when adding value
function Button({ children, variant = 'primary', ...props }: ButtonProps) {
  const className = `btn btn-${variant} ${props.className || ''}`
  return <button {...props} className={className}>{children}</button>
}

// ❌ Bad - Abstracting axios for no reason
class HttpClient {
  async get(url: string) { return axios.get(url) }
  async post(url: string, data: any) { return axios.post(url, data) }
}

// ✅ Good - Configure once, use directly
const api = axios.create({
  baseURL: import.meta.env.VITE_API_URL,
  headers: { 'Content-Type': 'application/json' }
})
```

---

## Backend (Node.js + Express + TypeScript) Rules

### Project Structure (MVC)
```
server/src/
├── controllers/     # HTTP request handlers only
├── services/        # Business logic only
├── routes/          # Route definitions only
├── middlewares/     # Middleware functions only
├── validations/     # Input validation schemas only
├── utils/           # Pure utility functions only
├── config/          # Configuration only
├── types/           # TypeScript types only
├── constants/       # Constants only
└── app.ts
```

### MVC Layer Responsibilities

#### Models (Prisma Schema)
```prisma
// prisma/schema.prisma

// ✅ Good - Database structure only
model Contact {
  id        String   @id @default(uuid())
  name      String
  email     String   @unique
  phone     String?
  agentId   String
  agent     User     @relation(fields: [agentId], references: [id])
  createdAt DateTime @default(now())
  
  @@index([agentId])
  @@index([email])
}

// ❌ Bad - Trying to add validation in schema (Prisma doesn't support this)
```

#### Controllers
```typescript
// controllers/contactController.ts

// ✅ Good - Thin controller, delegates to service
export const getContacts = async (req: Request, res: Response, next: NextFunction) => {
  try {
    const userId = req.user!.id
    const contacts = await contactService.getContactsByUser(userId)
    
    res.json({
      success: true,
      data: contacts
    })
  } catch (error) {
    next(error)
  }
}

export const createContact = async (req: Request, res: Response, next: NextFunction) => {
  try {
    const userId = req.user!.id
    const contactData = req.body
    
    const contact = await contactService.createContact(userId, contactData)
    
    res.status(201).json({
      success: true,
      data: contact
    })
  } catch (error) {
    next(error)
  }
}

// ❌ Bad - Fat controller with business logic
export const createContact = async (req: Request, res: Response) => {
  // 100 lines of validation
  // 50 lines of business logic
  // Database queries
  // Email sending
  // Google sync
  // All mixed together
}
```

#### Services
```typescript
// services/contactService.ts

// ✅ Good - Business logic layer
import prisma from '@/config/database'
import { CreateContactDto } from '@/types'
import { ForbiddenError, ValidationError } from '@/utils/errors'

export const getContactsByUser = async (userId: string) => {
  return await prisma.contact.findMany({
    where: { agentId: userId },
    include: { opportunities: true },
    orderBy: { createdAt: 'desc' }
  })
}

export const createContact = async (userId: string, data: CreateContactDto) => {
  // Business validation: Check duplicate email
  const existing = await prisma.contact.findFirst({
    where: { email: data.email, agentId: userId }
  })
  
  if (existing) {
    throw new ValidationError('Contact with this email already exists')
  }
  
  // Create contact
  return await prisma.contact.create({
    data: {
      ...data,
      agentId: userId
    }
  })
}

export const deleteContact = async (contactId: string, userId: string) => {
  const contact = await prisma.contact.findUnique({
    where: { id: contactId },
    include: { opportunities: true }
  })
  
  if (!contact) {
    throw new ValidationError('Contact not found')
  }
  
  if (contact.agentId !== userId) {
    throw new ForbiddenError('Not authorized')
  }
  
  // Business rule: Cannot delete locked contacts
  const hasWonOpportunity = contact.opportunities.some(
    opp => opp.stage === 'CLIENT_WON'
  )
  
  if (hasWonOpportunity) {
    throw new ForbiddenError('Cannot delete contact with won opportunities')
  }
  
  await prisma.contact.delete({ where: { id: contactId } })
}

// ❌ Bad - Service that's just a passthrough
export const createContact = async (data: CreateContactDto) => {
  return await prisma.contact.create({ data })
  // No business logic? Just call Prisma directly from controller!
}
```

#### Routes
```typescript
// routes/contactRoutes.ts

// ✅ Good - Clear route definitions
import { Router } from 'express'
import * as contactController from '@/controllers/contactController'
import { authenticate } from '@/middlewares/authenticate'
import { validateRequest } from '@/middlewares/validateRequest'
import { contactValidation } from '@/validations/contactValidation'

const router = Router()

router.use(authenticate)

router.get('/', contactController.getContacts)

router.post(
  '/',
  validateRequest(contactValidation.create),
  contactController.createContact
)

router.put(
  '/:id',
  validateRequest(contactValidation.update),
  contactController.updateContact
)

router.delete('/:id', contactController.deleteContact)

export default router

// ❌ Bad - Logic in routes
router.post('/', async (req, res) => {
  // 50 lines of logic directly in route
})
```

#### Validations
```typescript
// validations/contactValidation.ts

// ✅ Good - Input validation only
import Joi from 'joi'

export const contactValidation = {
  create: Joi.object({
    name: Joi.string().required().min(2).max(100).trim(),
    email: Joi.string().required().email().lowercase(),
    phone: Joi.string().optional().pattern(/^\+?[\d\s-()]+$/),
    company: Joi.string().optional().max(200)
  }),
  
  update: Joi.object({
    name: Joi.string().min(2).max(100).trim(),
    email: Joi.string().email().lowercase(),
    phone: Joi.string().pattern(/^\+?[\d\s-()]+$/),
    company: Joi.string().max(200)
  }).min(1)
}

// ❌ Bad - Business validation here
export const contactValidation = {
  create: Joi.object({
    name: Joi.string().required(),
    email: Joi.string().required().email().custom(async (value) => {
      // ❌ Don't do database queries in validation schema!
      const existing = await prisma.contact.findUnique({ where: { email: value } })
      if (existing) throw new Error('Email exists')
    })
  })
}
```

#### Middlewares
```typescript
// middlewares/authenticate.ts

// ✅ Good - Single responsibility
import jwt from 'jsonwebtoken'
import { Request, Response, NextFunction } from 'express'
import { UnauthorizedError } from '@/utils/errors'

export const authenticate = async (req: Request, res: Response, next: NextFunction) => {
  try {
    const token = req.headers.authorization?.split(' ')[1]
    
    if (!token) {
      throw new UnauthorizedError('No token provided')
    }
    
    const decoded = jwt.verify(token, process.env.JWT_SECRET!) as JwtPayload
    req.user = decoded
    
    next()
  } catch (error) {
    next(new UnauthorizedError('Invalid token'))
  }
}

// middlewares/authorize.ts
export const authorize = (...roles: string[]) => {
  return (req: Request, res: Response, next: NextFunction) => {
    if (!roles.includes(req.user!.role)) {
      throw new ForbiddenError('Access denied')
    }
    next()
  }
}

// ❌ Bad - Middleware doing too much
export const authenticate = async (req, res, next) => {
  // Check token
  // Load user from database
  // Check permissions
  // Log activity
  // Update last seen
  // Send analytics
  // 200 lines of mixed responsibilities
}
```

### Type Definitions
```typescript
// types/index.ts

// ✅ Good - Simple, clear types
export type User = {
  id: string
  name: string
  email: string
  role: 'ADMIN' | 'AGENT'
  createdAt: Date
}

export type Contact = {
  id: string
  name: string
  email: string
  phone?: string
  agentId: string
  createdAt: Date
}

export type CreateContactDto = Omit<Contact, 'id' | 'agentId' | 'createdAt'>
export type UpdateContactDto = Partial<CreateContactDto>

// ❌ Bad - Over-engineered types
export type ApiResponse<T, E = Error> = {
  data?: T
  error?: E
  meta: {
    timestamp: number
    requestId: string
    version: string
  }
}
// This is too generic for current needs!
```

### Error Handling
```typescript
// utils/errors.ts

// ✅ Good - Custom error classes for common cases
export class AppError extends Error {
  constructor(
    public message: string,
    public statusCode: number
  ) {
    super(message)
    this.name = this.constructor.name
  }
}

export class ValidationError extends AppError {
  constructor(message: string) {
    super(message, 400)
  }
}

export class UnauthorizedError extends AppError {
  constructor(message: string) {
    super(message, 401)
  }
}

export class ForbiddenError extends AppError {
  constructor(message: string) {
    super(message, 403)
  }
}

export class NotFoundError extends AppError {
  constructor(message: string) {
    super(message, 404)
  }
}

// middlewares/errorHandler.ts
export const errorHandler = (
  err: Error,
  req: Request,
  res: Response,
  next: NextFunction
) => {
  if (err instanceof AppError) {
    return res.status(err.statusCode).json({
      success: false,
      error: err.message
    })
  }
  
  console.error('Unexpected error:', err)
  
  res.status(500).json({
    success: false,
    error: 'Internal server error'
  })
}

// ❌ Bad - Generic error handling
throw new Error('Something went wrong') // No context!
```

### No Unnecessary Abstractions
```typescript
// ❌ Bad - Repository pattern (not needed with Prisma)
class ContactRepository {
  async findAll() { return prisma.contact.findMany() }
  async findById(id: string) { return prisma.contact.findUnique({ where: { id } }) }
  async create(data: any) { return prisma.contact.create({ data }) }
  // Just call Prisma directly!
}

// ✅ Good - Use Prisma directly in services
export const getContacts = async () => {
  return await prisma.contact.findMany()
}

// ❌ Bad - Base service class
abstract class BaseService<T> {
  abstract create(data: T): Promise<T>
  abstract update(id: string, data: T): Promise<T>
  // Unnecessary abstraction!
}

// ✅ Good - Direct service functions
export const createContact = async (data: CreateContactDto) => {
  // Specific implementation
}
```

---

## Database (Prisma) Rules

### Schema Design
```prisma
// ✅ Good - Clear, simple schema
model Contact {
  id        String   @id @default(uuid())
  name      String
  email     String   @unique
  phone     String?
  agentId   String
  agent     User     @relation(fields: [agentId], references: [id])
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  
  @@index([agentId])
  @@index([email])
}

// ❌ Bad - Over-indexed
model Contact {
  id        String   @id @default(uuid())
  name      String
  email     String   @unique
  
  @@index([id])          // Already primary key!
  @@index([name])        // Do you actually search by name?
  @@index([createdAt])   // Do you sort by this often?
  @@index([updatedAt])   // Do you need this?
}
```

### Query Patterns
```typescript
// ✅ Good - Specific queries
const contacts = await prisma.contact.findMany({
  where: { agentId: userId },
  include: { opportunities: true }
})

// ✅ Good - Use select for specific fields
const contact = await prisma.contact.findUnique({
  where: { id: contactId },
  select: { id: true, name: true, email: true }
})

// ❌ Bad - Over-fetching
const contacts = await prisma.contact.findMany({
  include: {
    opportunities: {
      include: {
        files: true,
        timeline: true,
        agent: {
          include: {
            contacts: true,
            opportunities: true
          }
        }
      }
    }
  }
})
// Loading entire database!
```

---

## Testing Rules

### What to Test
```typescript
// ✅ Test business logic in services
describe('ContactService', () => {
  it('should not allow deleting locked contacts', async () => {
    // Test the business rule
  })
})

// ✅ Test API endpoints
describe('POST /api/contacts', () => {
  it('should create a contact', async () => {
    const response = await request(app)
      .post('/api/contacts')
      .send({ name: 'John', email: 'john@example.com' })
    
    expect(response.status).toBe(201)
  })
})

// ❌ Don't test frameworks
it('should render a button', () => {
  // Testing React's rendering? Don't!
})

// ❌ Don't test third-party libraries
it('should hash password with bcrypt', () => {
  // Testing bcrypt? Don't!
})
```

---

## Environment & Configuration

### Environment Variables
```typescript
// config/env.ts

// ✅ Good - Validate and type env vars
import { z } from 'zod'

const envSchema = z.object({
  NODE_ENV: z.enum(['development', 'production', 'test']),
  PORT: z.string().transform(Number),
  DATABASE_URL: z.string().url(),
  JWT_SECRET: z.string().min(32),
  GOOGLE_CLIENT_ID: z.string(),
  GOOGLE_CLIENT_SECRET: z.string()
})

export const env = envSchema.parse(process.env)

// ❌ Bad - Direct process.env usage everywhere
const secret = process.env.JWT_SECRET // Might be undefined!
```

---

## Git & Code Organization

### File Naming
- Components: PascalCase (`ContactCard.tsx`)
- Utilities: camelCase (`formatDate.ts`)
- Constants: UPPER_SNAKE_CASE (`API_ROUTES.ts`)
- Types: PascalCase (`Contact.ts` or in `types/index.ts`)

### Import Order
```typescript
// 1. External libraries
import { useState, useEffect } from 'react'
import axios from 'axios'

// 2. Internal modules (absolute imports)
import { Contact } from '@/types'
import { contactService } from '@/services/contactService'

// 3. Relative imports
import { ContactCard } from './ContactCard'
import './styles.css'
```

### No Commented Code
```typescript
// ❌ Bad
function createContact() {
  // const oldWay = doSomething()
  // return oldWay
  
  const newWay = doSomethingElse()
  return newWay
}

// ✅ Good - Delete old code, use git history
function createContact() {
  const result = doSomethingElse()
  return result
}
```

---

## Performance Rules

### Only Optimize When Needed
```typescript
// ❌ Bad - Premature optimization
const memoizedValue = useMemo(() => {
  return simpleCalculation()
}, [dependency])

// ✅ Good - Use when actually expensive
const memoizedValue = useMemo(() => {
  return expensiveCalculation() // Proven to be slow
}, [dependency])

// ❌ Bad - Unnecessary useCallback
const handleClick = useCallback(() => {
  doSomething()
}, [])

// ✅ Good - Use when passing to memoized children
const handleClick = useCallback(() => {
  doSomething()
}, [])
// Only if <MemoizedChild onClick={handleClick} />
```

---

## Security Rules

### Authentication & Authorization
```typescript
// ✅ Always check authentication
router.get('/contacts', authenticate, getContacts)

// ✅ Check authorization for sensitive operations
router.delete('/contacts/:id', authenticate, authorize('ADMIN'), deleteContact)

// ❌ Never trust client input
const userId = req.body.userId // ❌ Client can fake this!
const userId = req.user.id     // ✅ From verified token
```

### Input Validation
```typescript
// ✅ Always validate user input
router.post('/', validateRequest(schema), createContact)

// ❌ Never use user input directly in queries (Prisma protects against SQL injection, but still validate)
```

---

## Documentation Rules

### When to Comment
```typescript
// ✅ Good - Explain WHY, not WHAT
// Using setTimeout instead of setInterval because we need to wait
// for each sync to complete before starting the next one
setTimeout(syncContacts, 60000)

// ❌ Bad - Commenting the obvious
// Loop through contacts
contacts.forEach(contact => {
  // Print contact name
  console.log(contact.name)
})
```

### README Requirements
- Project setup instructions
- Environment variables needed
- How to run locally
- Tech stack
- No unnecessary sections (we're building an MVP, not a framework!)

---

## When to Break These Rules

### You CAN break these rules when:
1. There's a specific, documented reason
2. The benefit clearly outweighs the complexity
3. You've considered simpler alternatives
4. The team agrees

### You CANNOT break these rules for:
1. "It might be useful later"
2. "This is how I did it before"
3. "This is more elegant"
4. "Just in case"

---

## Code Review Checklist

Before submitting code, ask yourself:
- [ ] Is this code needed RIGHT NOW for current requirements?
- [ ] Can I explain what this code does in one sentence?
- [ ] Have I deleted unused code?
- [ ] Are there any "just in case" utilities or abstractions?
- [ ] Is the file in the correct directory?
- [ ] Did I avoid over-engineering?
- [ ] Would a new developer understand this in 5 minutes?

---

---

## UI/Design System Rules

### Design Philosophy
- **Modern, Soft, Fluid**: The UI must feel smooth, modern, and fluid with soft transitions
- **Consistent**: Every component must follow the same design patterns regardless of who writes the code
- **Theme-Aware**: All components must support both light and dark themes seamlessly
- **Accessible**: Maintain proper contrast ratios and focus states

### Color System

#### Primary Colors (Purple-Based) - FROM DESIGN FILES
The application uses purple as the primary brand color. All UI elements must use these EXACT color values from the design files:

**Primary Color:**
- Primary Purple: `#7f19e6` (primary / primary-600) - MAIN BRAND COLOR
- Primary Hover: `#6814bd` (primary-hover / primary-700)
- Primary Light: `#c4b5fd` (primary-400)
- Primary Dark: `#5b21b6` (primary-800)

**Light Theme:**
- Background: `#f7f6f8` (background-light)
- Surface: `#ffffff` (white)
- Text Primary: `#141118` (text-main)
- Text Secondary: `#756388` (text-muted)
- Border: `#e5e7eb` (neutral-200)

**Dark Theme:**
- Background: `#191121` (background-dark)
- Surface: `#231b2e` (surface-dark)
- Surface Darker: `#130d1a` (surface-darker) - for sidebars
- Surface Alt: `#1e1427` (surface-dark-alt)
- Text Primary: `#ffffff` (white)
- Text Secondary: `#ab9db8` (text-muted-dark)
- Border: `#302938` (border-dark)

#### Semantic Colors
- Success: `#10B981` (green-500)
- Warning: `#F59E0B` (amber-500)
- Error: `#EF4444` (red-500)
- Info: `#3B82F6` (blue-500)

### Spacing System
Use Tailwind's spacing scale consistently:
- `xs`: 0.5rem (8px)
- `sm`: 0.75rem (12px)
- `md`: 1rem (16px)
- `lg`: 1.5rem (24px)
- `xl`: 2rem (32px)
- `2xl`: 3rem (48px)
- `3xl`: 4rem (64px)

### Border Radius - FROM DESIGN FILES
- `sm`: 0.375rem (6px) - Small elements (badges, tags)
- `DEFAULT`: 0.5rem (8px) - **Default for buttons, inputs, cards** (use `rounded-lg` or `rounded`)
- `md`: 0.5rem (8px) - Same as default
- `lg`: 0.75rem (12px) or 1rem (16px) - Large elements (modals, drawers)
- `xl`: 1.5rem (24px) - Extra large (containers, hero sections)
- `2xl`: 2rem (32px) - Very large containers
- `full`: 9999px - Pills, avatars, fully rounded

### Typography - FROM DESIGN FILES
- **Display Font**: `Space Grotesk` - For headings, titles, brand text
- **Body Font**: `Noto Sans` - For body text, descriptions
- **Icons**: `Material Symbols Outlined` - Google Material Icons
- Font Sizes:
  - `xs`: 0.75rem (12px)
  - `sm`: 0.875rem (14px)
  - `base`: 1rem (16px)
  - `lg`: 1.125rem (18px)
  - `xl`: 1.25rem (20px)
  - `2xl`: 1.5rem (24px)
  - `3xl`: 1.875rem (30px)
  - `4xl`: 2.25rem (36px)
  - `5xl`: 3rem (48px) - Large hero text
  - `6xl`: 3.75rem (60px) - Extra large hero text

### Shadows - FROM DESIGN FILES
- `sm`: `0 1px 2px 0 rgb(0 0 0 / 0.05)`
- `md`: `0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1)`
- `lg`: `0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1)`
- `xl`: `0 20px 25px -5px rgb(0 0 0 / 0.1), 0 8px 10px -6px rgb(0 0 0 / 0.1)`
- **`glow`**: `0 0 20px -5px rgba(127, 25, 230, 0.3)` - Primary glow shadow
- **`glow-hover`**: `0 0 30px -5px rgba(127, 25, 230, 0.5)` - Glow on hover
- **`soft`**: `0 4px 20px -2px rgba(127, 25, 230, 0.1)` - Soft purple shadow
- **`card`**: `0 2px 8px -1px rgba(0,0,0,0.05)` - Card shadow

### Component Patterns

#### Buttons - BUSINESS CRM STANDARDIZED

**CRITICAL: All buttons must follow these exact patterns for consistency across Contacts, Pipeline, and Opportunities pages.**

```typescript
// ✅ Good - Primary Button (Standardized Medium Size)
<button className="px-4 py-2 bg-primary text-white rounded-md text-sm font-medium shadow-sm hover:bg-primary-hover hover:shadow-md active:bg-primary-800 active:scale-[0.98] focus:outline-none focus:ring-2 focus:ring-primary/20 transition-all duration-200">
  <span className="flex items-center gap-1.5">
    <span className="material-symbols-outlined text-[16px]">add</span>
    <span>Button Text</span>
  </span>
</button>

// Primary Button Pattern (Use for all primary actions)
className="px-4 py-2 bg-primary text-white rounded-md text-sm font-medium shadow-sm hover:bg-primary-hover hover:shadow-md active:bg-primary-800 active:scale-[0.98] focus:outline-none focus:ring-2 focus:ring-primary/20 transition-all duration-200"

// Secondary Button Pattern
className="px-4 py-2 text-sm font-medium text-gray-700 dark:text-gray-300 hover:text-gray-900 dark:hover:text-white bg-white dark:bg-surface-dark border border-neutral-200 dark:border-[#302938] rounded-md hover:bg-neutral-50 dark:hover:bg-[#302938] hover:shadow-sm active:scale-[0.98] focus:outline-none focus:ring-2 focus:ring-primary/20 transition-all duration-200"

// Icon Button Pattern
className="size-9 flex items-center justify-center rounded-md bg-white dark:bg-surface-dark border border-neutral-200 dark:border-slate-700 text-gray-600 dark:text-gray-400 hover:text-gray-900 dark:hover:text-white hover:bg-neutral-50 dark:hover:bg-slate-700 transition-colors"

// ❌ Bad - Wrong size, missing hover effects, soft gray text
<button className="px-3 py-1.5 bg-primary text-white rounded-md text-xs">Click</button>
<button className="px-6 py-3.5 bg-primary text-white">Too Large</button>
<span className="text-text-muted">Soft gray - hard to read</span>
```

**Button Size Rules:**
- **Standard Medium Size**: `px-4 py-2` with `text-sm` - Use for all primary and secondary buttons
- **Not too large**: Never use `px-6 py-3.5` or larger
- **Not too short**: Never use `px-2 py-1` or smaller
- **Icon size**: `text-[16px]` for button icons, `gap-1.5` for icon spacing

**Button Hover Effects (Required):**
- **Primary buttons**: `hover:bg-primary-hover hover:shadow-md active:bg-primary-800 active:scale-[0.98]`
- **Secondary buttons**: `hover:bg-neutral-50 hover:shadow-sm active:scale-[0.98]`
- **All buttons**: Must include `transition-all duration-200`

#### Cards - FROM DESIGN FILES
```typescript
// ✅ Good - Standard card from design files
<div className="bg-white dark:bg-surface-dark rounded-xl shadow-card border border-neutral-200 dark:border-[#302938]/50 p-4 transition-all hover:scale-[1.005] hover:shadow-lg group">
  {/* Card content */}
</div>

// Glass Panel Card (from design files - dark theme)
className="glass-panel rounded-2xl border border-[#302938]/50 p-4 transition-all hover:bg-[#2d243a]/80 hover:scale-[1.005] hover:shadow-lg group"

// Standard Card Pattern
className="bg-white dark:bg-surface-dark rounded-xl shadow-card border border-neutral-200 dark:border-[#302938]/50 p-6 transition-all hover:scale-[1.005] hover:shadow-lg"

// Kanban Card (from design files)
className="bg-white p-4 rounded-xl shadow-card border border-transparent hover:border-primary/30 cursor-grab transition-all group"

// ❌ Bad - Hardcoded colors, no hover effects, wrong border radius
<div className="bg-white rounded p-4">
```

#### Input Fields - FROM DESIGN FILES
```typescript
// ✅ Good - Input from design files
<input 
  className="w-full px-4 py-3.5 border border-neutral-200 dark:border-[#302938] rounded-lg bg-neutral-50 dark:bg-surface-dark text-neutral-900 dark:text-white placeholder:text-neutral-400 dark:placeholder:text-text-muted-dark focus:border-primary focus:bg-white dark:focus:bg-surface-dark focus:outline-none focus:ring-4 focus:ring-primary/10 transition-all duration-200"
/>

// Input with Icon (from design files)
<div className="relative group">
  <input className="w-full px-4 py-3.5 pl-10 border border-neutral-200 dark:border-[#302938] rounded-lg bg-neutral-50 dark:bg-surface-dark text-neutral-900 dark:text-white placeholder:text-neutral-400 dark:placeholder:text-text-muted-dark focus:border-primary focus:bg-white dark:focus:bg-surface-dark focus:outline-none focus:ring-4 focus:ring-primary/10 transition-all duration-200" />
  <span className="absolute right-4 top-1/2 -translate-y-1/2 text-neutral-400 group-focus-within:text-primary transition-colors">
    <span className="material-symbols-outlined text-[20px]">search</span>
  </span>
</div>

// ❌ Bad - Missing dark mode, wrong padding, wrong border radius
<input className="border rounded p-2" />
```

#### Badges/Tags
```typescript
// ✅ Good - Consistent badge styling
<span className="px-2 py-1 text-xs font-medium bg-primary-100 dark:bg-primary-900/30 text-primary-700 dark:text-primary-300 rounded-full">
  New
</span>

// Status Badges
// Success: bg-green-100 dark:bg-green-900/30 text-green-700 dark:text-green-300
// Warning: bg-amber-100 dark:bg-amber-900/30 text-amber-700 dark:text-amber-300
// Error: bg-red-100 dark:bg-red-900/30 text-red-700 dark:text-red-300
```

### Theme Implementation

#### Always Use Theme-Aware Classes
```typescript
// ✅ Good - Theme-aware
<div className="bg-white dark:bg-slate-800 text-gray-900 dark:text-slate-100">
  <p className="text-gray-600 dark:text-slate-400">Secondary text</p>
</div>

// ❌ Bad - Hardcoded colors
<div className="bg-white text-black">
  <p className="text-gray-600">Secondary text</p>
</div>
```

#### Gradient Backgrounds
```typescript
// ✅ Good - Purple gradient for hero sections
<div className="bg-gradient-to-br from-primary-700 via-primary-600 to-primary-500">
  {/* Content */}
</div>

// Dark theme gradient
<div className="bg-gradient-to-br from-slate-900 via-primary-900 to-slate-800">
  {/* Content */}
</div>
```

### Animation & Transitions - FROM DESIGN FILES

#### Standard Transitions
- All interactive elements must have smooth transitions
- Duration: `200ms` for colors, `300ms` for transforms
- Easing: `ease-in-out` for most, `ease-out` for entrances

#### Hover Effects - FROM DESIGN FILES
- **Cards**: `hover:scale-[1.005]` - Subtle scale on hover
- **Buttons**: `hover:-translate-y-0.5` - Lift effect on hover
- **Buttons Active**: `active:scale-[0.98]` - Press down effect
- **Icons**: `group-hover:scale-110` - Icon scale on parent hover
- **Text**: `group-hover:text-primary` - Text color change on hover

```typescript
// ✅ Good - Hover effects from design files
className="transition-all duration-200 hover:scale-[1.005] hover:shadow-lg"

// Button hover pattern
className="hover:-translate-y-0.5 active:scale-[0.98] transition-all duration-200"

// Card hover pattern
className="hover:scale-[1.005] hover:shadow-lg transition-all duration-200 group"

// Standard transition classes
transition-colors duration-200  // For color changes
transition-all duration-200     // For multiple properties
transition-transform duration-300 // For transforms
```

### Scrollbar Behavior - FROM DESIGN FILES

#### Auto-Scrollbar Pattern
**CRITICAL**: All scrollable elements throughout the application MUST use the auto-scrollbar pattern:
- **Hide scrollbars by default** - Clean, minimal UI when not scrolling
- **Show scrollbars on hover** - Appears when user hovers over scrollable area
- **Smooth transitions** - Scrollbar fades in/out with 0.2s transition

#### Implementation
```typescript
// ✅ Good - Use auto-scrollbar class for all scrollable elements
<div className="overflow-y-auto auto-scrollbar">
  {/* Scrollable content */}
</div>

<div className="overflow-x-auto auto-scrollbar">
  {/* Horizontally scrollable content */}
</div>

// ✅ Good - Specific scrollbar classes for pipeline
<div className="overflow-x-auto pipeline-scrollbar">
  {/* Pipeline horizontal scroll */}
</div>

<div className="overflow-y-auto stage-column-scrollbar">
  {/* Stage column vertical scroll */}
</div>

// ❌ Bad - Missing auto-scrollbar class
<div className="overflow-y-auto">
  {/* Scrollbar always visible - cluttered UI */}
</div>
```

#### Scrollbar Classes Available
1. **`auto-scrollbar`** - General purpose, hide by default, show on hover
   - Use for: Sidebars, main content areas, dropdowns, panels, tables
   - Works for both vertical and horizontal scrolling

2. **`pipeline-scrollbar`** - Pipeline-specific horizontal scrollbar
   - Use for: Kanban board horizontal scrolling

3. **`stage-column-scrollbar`** - Stage column vertical scrollbar
   - Use for: Individual stage columns in pipeline

4. **`no-scrollbar`** - Completely hide scrollbar (use sparingly)
   - Use for: Auth pages, special cases where scrollbar must be hidden

#### Rules
- **ALWAYS** add `auto-scrollbar` class to any element with `overflow-y-auto` or `overflow-x-auto`
- **EXCEPTION**: Auth pages may use `no-scrollbar` for full-screen layouts
- **EXCEPTION**: Pipeline-specific scrollbars use their dedicated classes
- Scrollbars must support both light and dark themes
- Scrollbar width: 8px (thin)
- Scrollbar thumb color: Light gray in light mode, slate in dark mode
- Transition duration: 0.2s for smooth appearance

### Tooltip Behavior - FROM DESIGN FILES

#### Custom Tooltip Pattern
**CRITICAL**: All tooltips throughout the application MUST use the custom styled tooltip:
- **Custom styled tooltip** - Black background with white text, appears above element
- **Show on hover** - Only visible when hovering over the element
- **Hide when open** - Tooltip disappears when dropdown/modal is open
- **Consistent styling** - Same appearance across all filter components

#### Implementation
```typescript
// ✅ Good - Custom tooltip pattern
<div className="relative group">
  <button className="...">
    {label}
  </button>
  
  {/* Custom tooltip showing filter name on hover */}
  {!isOpen && (
    <div className="absolute bottom-full left-1/2 -translate-x-1/2 mb-2 px-2 py-1 bg-black/90 text-white text-xs rounded-md opacity-0 group-hover:opacity-100 transition-opacity duration-200 pointer-events-none whitespace-nowrap z-[60]">
      {label}
      <div className="absolute top-full left-1/2 -translate-x-1/2 w-0 h-0 border-l-4 border-r-4 border-t-4 border-transparent border-t-black/90"></div>
    </div>
  )}
</div>

// ❌ Bad - Native browser tooltip
<button title={label}>
  {label}
</button>

// ❌ Bad - Tooltip visible when dropdown is open
{isOpen && <div className="tooltip">...</div>}
```

#### Tooltip Styling Rules
- **Background**: `bg-black/90` (90% opacity black)
- **Text**: White text, `text-xs` size
- **Position**: Above element (`bottom-full`), centered (`left-1/2 -translate-x-1/2`)
- **Arrow**: Small triangle pointing down using border trick
- **Animation**: `opacity-0 group-hover:opacity-100` with `transition-opacity duration-200`
- **Z-index**: `z-[60]` to appear above other elements
- **Pointer events**: `pointer-events-none` so tooltip doesn't interfere with clicks

#### Rules
- **ALWAYS** use custom styled tooltip for filter/input elements
- **ALWAYS** wrap parent in `group` class for hover detection
- **ALWAYS** hide tooltip when dropdown/modal is open (`{!isOpen && ...}`)
- **ALWAYS** use the exact same styling classes for consistency
- **NEVER** use native browser `title` attribute for tooltips
- Tooltip appears above the element (centered)
- Tooltip has a small arrow pointing down to the element

### Layout Patterns

#### Container
```typescript
// ✅ Good - Consistent container
<div className="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8">
  {/* Content */}
</div>
```

#### Grid Layouts
```typescript
// ✅ Good - Responsive grid
<div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6">
  {/* Grid items */}
</div>
```

#### Flex Layouts
```typescript
// ✅ Good - Consistent flex patterns
<div className="flex items-center justify-between gap-4">
  {/* Content */}
</div>
```

### Required Patterns for All Components

1. **Dark Mode Support**: Every component MUST support dark mode using `dark:` prefix
2. **Hover States**: All interactive elements MUST have hover states
3. **Focus States**: All focusable elements MUST have visible focus rings
4. **Transitions**: All state changes MUST use transitions
5. **Responsive**: All components MUST be responsive (mobile-first)
6. **Accessibility**: Proper ARIA labels and semantic HTML

### Component Examples

#### Modal/Drawer
```typescript
// ✅ Good - Consistent modal pattern
<div className="fixed inset-0 bg-black/50 dark:bg-black/70 backdrop-blur-sm z-50 flex items-center justify-center p-4">
  <div className="bg-white dark:bg-slate-800 rounded-lg shadow-xl max-w-2xl w-full p-6 border border-gray-200 dark:border-slate-700">
    {/* Modal content */}
  </div>
</div>
```

#### Sidebar
```typescript
// ✅ Good - Consistent sidebar
<aside className="w-64 bg-white dark:bg-slate-800 border-r border-gray-200 dark:border-slate-700 h-screen sticky top-0">
  {/* Sidebar content */}
</aside>
```

#### Kanban Card
```typescript
// ✅ Good - Consistent card styling
<div className="bg-white dark:bg-slate-800 rounded-lg shadow-sm border border-gray-200 dark:border-slate-700 p-4 hover:shadow-md transition-shadow cursor-move">
  {/* Card content */}
</div>
```

### Color Usage Rules

1. **Primary Purple**: Use for primary actions, links, active states, highlights
2. **Gray Scale**: Use for text, borders, backgrounds (never use pure black/white)
3. **Semantic Colors**: Use only for their intended purpose (success, warning, error)
4. **Never Hardcode**: Always use Tailwind classes, never inline hex colors
5. **Dark Mode**: Always provide dark mode variants

### Spacing Rules

1. **Consistent Gaps**: Use `gap-4`, `gap-6`, `gap-8` for consistent spacing
2. **Padding**: Use `p-4`, `p-6`, `p-8` for containers
3. **Margins**: Use `mb-4`, `mb-6`, `mt-4`, etc. for vertical spacing
4. **No Magic Numbers**: Never use arbitrary values like `p-[13px]`

### Typography Rules

1. **Headings**: Use semantic heading tags (`h1`, `h2`, etc.) with appropriate sizes
2. **Font Weights**: 
   - Regular: `font-normal` (400)
   - Medium: `font-medium` (500)
   - Semibold: `font-semibold` (600)
   - Bold: `font-bold` (700)
3. **Line Heights**: Use default Tailwind line heights
4. **Text Colors**: Always use theme-aware text colors
   - **CRITICAL**: Never use soft gray colors (`text-text-muted`, `text-neutral-400`, `text-gray-400`)
   - **Use dark gray/black for readability**: 
     - Primary text: `text-gray-800 dark:text-gray-200` or `text-gray-900 dark:text-gray-100`
     - Secondary text: `text-gray-700 dark:text-gray-300`
     - Labels/descriptions: `text-gray-700 dark:text-gray-300`
     - Icons: `text-gray-600 dark:text-gray-400`
   - **Client preference**: Dark gray and black are fine, soft gray is harder to read

### Icon Usage

1. **Size**: Use consistent icon sizes (`w-4 h-4`, `w-5 h-5`, `w-6 h-6`)
2. **Color**: Inherit text color or use `text-gray-500 dark:text-slate-400`
3. **Spacing**: Add appropriate spacing with icons (`gap-2`, `gap-3`)

### Form Elements

#### Input Group
```typescript
// ✅ Good - Consistent form styling
<div className="space-y-2">
  <label className="block text-sm font-medium text-gray-700 dark:text-slate-300">
    Email
  </label>
  <input 
    type="email"
    className="w-full px-4 py-2 border border-gray-300 dark:border-slate-600 rounded-md bg-white dark:bg-slate-800 text-gray-900 dark:text-slate-100 focus:ring-2 focus:ring-primary-500 focus:border-transparent"
  />
</div>
```

### Error States
```typescript
// ✅ Good - Consistent error styling
<div className="text-sm text-red-600 dark:text-red-400 mt-1">
  {errorMessage}
</div>
```

### Loading States
```typescript
// ✅ Good - Consistent loading spinner
<div className="flex items-center justify-center">
  <div className="w-6 h-6 border-2 border-primary-600 border-t-transparent rounded-full animate-spin" />
</div>
```

### Code Generation Rules

When generating UI code, ALWAYS:
1. Include dark mode variants for all colors
2. Add hover and focus states
3. Include transitions
4. Use consistent spacing from the spacing scale
5. Follow the exact color values specified above
6. Use rounded corners (md for most elements)
7. Add proper shadows
8. Ensure responsive design

### Example: Complete Component Pattern - FROM DESIGN FILES

```typescript
// ✅ Good - Complete component following design files exactly
type ButtonProps = {
  children: React.ReactNode
  onClick?: () => void
  variant?: 'primary' | 'secondary'
  disabled?: boolean
}

export function Button({ children, onClick, variant = 'primary', disabled }: ButtonProps) {
  const baseClasses = "px-6 py-3.5 rounded-lg font-bold transition-all duration-200 focus:outline-none disabled:opacity-50 disabled:cursor-not-allowed"
  
  const variantClasses = variant === 'primary'
    ? "bg-primary text-white shadow-glow hover:shadow-glow-hover hover:-translate-y-0.5 active:scale-[0.98] focus:ring-4 focus:ring-primary/20"
    : "bg-white dark:bg-surface-dark text-primary border border-neutral-200 dark:border-[#302938] hover:bg-neutral-50 dark:hover:bg-[#302938] focus:ring-2 focus:ring-primary/20"
  
  return (
    <button
      onClick={onClick}
      disabled={disabled}
      className={`${baseClasses} ${variantClasses}`}
    >
      {children}
    </button>
  )
}
```

---

## Remember

**"Make it work, make it right, make it fast" - in that order.**

Write code for humans first, computers second. The best code is code that doesn't need to exist. Delete ruthlessly. Abstract reluctantly. Optimize rarely.

**UI Consistency**: No matter who writes the code or which AI generates it, the UI must look and feel identical. Follow these design system rules religiously.

